Ralph Loops: The "Fresh Context" Pattern
Ralph Loops (aka the "Ralph Wiggum" technique) are a deterministic orchestration pattern for autonomous LLM coding agents. The core philosophy is persistence over intelligence. It addresses the "malloc without free" problem in LLM context windows by enforcing a hard context reset after every unit of work.
Origin: Coined by Geoffrey Huntley.
** namesake:** Ralph Wiggum (The Simpsons) — "I'm helping!" (Naive persistence).
1. The Core Architecture
Unlike "vibe coding" or long-context chat sessions where the context window accumulates noise (context rot), a Ralph Loop treats every iteration as a new process.
The Mechanism
It is literally a Bash while loop wrapping the claude CLI.
 * Init: Pull state from file system.
 * Act: Agent attempts one task from the queue.
 * Verify: Run tests/linters.
 * Commit: If verified, commit to git.
 * Reset: Kill the agent process. Clear the context.
 * Repeat.
State Persistence (The "External Memory")
Since the LLM memory is wiped every loop, state must be persisted to disk.
 * PRD.md / tasks.json: The immutable source of truth for requirements.
 * progress.txt: An append-only log file where the agent writes what it just did and what it learned. This is read at the start of the next loop.
 * Git History: The file system is the ultimate state. The agent relies on git diff and file reads to orient itself.
2. Implementation with Claude Code
In the context of Anthropic's claude CLI, a Ralph Loop bypasses the internal context management (compaction) which often degrades performance after ~100k tokens.
Typical Loop Logic (Pseudo-Bash):
while true; do
  # 1. Read the plan and progress
  # 2. Run Claude in non-interactive / headless mode
  # 3. Instruction: "Pick the next incomplete task. Do it. Update progress.txt. Exit."
  
  result=$(claude -p "Review PRD.md and progress.txt. Implement the next pending item. Run 'npm test'. If pass, commit. If fail, log to progress.txt.")

  # Check for "completion promise" (a specific XML tag or string to break the loop)
  if [[ "$result" == *"<promise>ALL_DONE</promise>"* ]]; then
    break
  fi
done

Critical Flags & Settings:
 * --dangerously-skip-permissions: Essential for true autonomy. Without this, the loop hangs on tool use approval.
 * Prompt Engineering: The system prompt must explicitly instruct the agent to not try to do everything at once. "One atomic commit per loop."
3. The "Dumb Zone" & Optimization
Ralph loops mitigate the "Dumb Zone"—the performance cliff agents hit when context saturation exceeds ~60-80%.
 * Cost vs. Quality: Ralph loops are token-inefficient (re-reading the PRD every time) but quality-efficient (no hallucination from stale context).
 * Feedback Loops: The technique fails without robust automated verification. If npm test isn't reliable, Ralph will hallucinate progress.
 * Guardrails: Advanced implementations use a "Reviewer" agent (separate model) to gate commits before the loop continues.
4. Use Cases
 * Greenfield TDD: "Here are the spec files. Write tests, then implementation, until all pass."
 * Migrations: "Convert these 50 files from Class Components to Functional Components."
 * Entropy Reduction: "Find and fix lint errors until eslint returns exit code 0."
